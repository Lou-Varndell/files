package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/middleware"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/aws/aws-sdk-go-v2/service/sts"
	"github.com/aws/smithy-go/logging"
)

// awsLogger implements the logging.Logger interface for AWS SDK v2
type awsLogger struct {
	logger *log.Logger
}

// Logf logs the formatted message with the given level
func (l *awsLogger) Logf(classification logging.Classification, format string, v ...interface{}) {
	l.logger.Printf("[%s] %s", classification, fmt.Sprintf(format, v...))
}

// CredentialsLogger is a middleware that logs credential resolution usage.
var CredentialsLogger = middleware.FinalizeMiddlewareFunc("CredentialsLogger", func(
	ctx context.Context, in middleware.FinalizeInput, next middleware.FinalizeHandler,
) (
	middleware.FinalizeOutput, middleware.Metadata, error,
) {
	if creds, ok := middleware.GetSigningCredentials(ctx); ok {
		log.Printf("[CredsCache] Using credentials: AccessKeyId=%s Expiry=%v",
			creds.AccessKeyID, creds.Expires)
	} else {
		log.Println("[CredsCache] No signing credentials found in context")
	}
	return next.HandleFinalize(ctx, in)
})

// NewLoggedConfig loads AWS config and adds credential-logging middleware.
func NewLoggedConfig(ctx context.Context, opts ...func(*config.LoadOptions) error) (aws.Config, error) {
	cfg, err := config.LoadDefaultConfig(ctx, opts...)
	if err != nil {
		return cfg, err
	}

	cfg.APIOptions = append(cfg.APIOptions, func(stack *middleware.Stack) error {
		return stack.Finalize.Add(CredentialsLogger, middleware.After)
	})

	return cfg, nil
}

// Example usage with an AWS client (e.g., STS)
func Example() error {
	ctx := context.Background()
	cfg, err := NewLoggedConfig(ctx)
	if err != nil {
		return err
	}

	client := sts.NewFromConfig(cfg)
	_, err = client.GetCallerIdentity(ctx, &sts.GetCallerIdentityInput{})
	return err
}

func main() {
	// Endpoint and region for LocalStack
	endpoint := "http://localhost:4566"
	region := "us-west-2"

	// Load SDK config with custom endpoint and dummy credentials
	cfg, err := config.LoadDefaultConfig(context.TODO(),
		config.WithRegion(region),
		config.WithCredentialsProvider(
			credentials.StaticCredentialsProvider{
				Value: aws.Credentials{
					AccessKeyID:     "test",
					SecretAccessKey: "test",
					SessionToken:    "test",
					Source:          "hardcoded dummy credentials",
				},
			},
		),
	)
	if err != nil {
		log.Fatalf("unable to load SDK config: %v", err)
	}

	// Create a logger that implements the logging.Logger interface
	logger := &awsLogger{logger: log.New(os.Stdout, "[DynamoDB] ", log.LstdFlags)}

	// Create a new DynamoDB client with logging middleware
	client := dynamodb.NewFromConfig(cfg, func(o *dynamodb.Options) {
		o.BaseEndpoint = aws.String(endpoint)
		o.ClientLogMode = aws.LogRequestWithBody | aws.LogResponseWithBody
		o.Logger = logger

		// Add request/response logging middleware
		o.APIOptions = append(o.APIOptions, func(stack *middleware.Stack) error {
			return stack.Initialize.Add(middleware.InitializeMiddlewareFunc("logger",
				func(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (
					out middleware.InitializeOutput, metadata middleware.Metadata, err error) {
					logger.Logf(logging.Debug, "Request: %+v", in)
					return next.HandleInitialize(ctx, in)
				},
			), middleware.After)
		})
	})

	// 1. Create table
	tableName := "MyTable"
	_, err = client.CreateTable(context.TODO(), &dynamodb.CreateTableInput{
		TableName: &tableName,
		KeySchema: []types.KeySchemaElement{
			{AttributeName: aws.String("ID"), KeyType: types.KeyTypeHash},
		},
		AttributeDefinitions: []types.AttributeDefinition{
			{AttributeName: aws.String("ID"), AttributeType: types.ScalarAttributeTypeS},
		},
		BillingMode: types.BillingModePayPerRequest,
	})
	if err != nil {
		log.Fatalf("failed to create table: %v", err)
	}
	fmt.Println("Table created:", tableName)

	// 2. Put item into the table
	_, err = client.PutItem(context.TODO(), &dynamodb.PutItemInput{
		TableName: &tableName,
		Item: map[string]types.AttributeValue{
			"ID":   &types.AttributeValueMemberS{Value: "123"},
			"Name": &types.AttributeValueMemberS{Value: "LocalUser"},
		},
	})
	if err != nil {
		log.Fatalf("failed to put item: %v", err)
	}
	fmt.Println("Inserted item into table")

	// 3. Get item
	resp, err := client.GetItem(context.TODO(), &dynamodb.GetItemInput{
		TableName: &tableName,
		Key: map[string]types.AttributeValue{
			"ID": &types.AttributeValueMemberS{Value: "123"},
		},
	})
	if err != nil {
		log.Fatalf("failed to get item: %v", err)
	}

	nameAttr := resp.Item["Name"].(*types.AttributeValueMemberS)
	fmt.Printf("Fetched item: ID=%s, Name=%s\n", "123", nameAttr.Value)
}
