package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/middleware"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/aws/smithy-go/logging"
)

// LoggingMiddleware wraps a DynamoDB client to add logging
type LoggingMiddleware struct {
	client *dynamodb.Client
}

// NewLoggingMiddleware creates a new logging middleware for DynamoDB client
func NewLoggingMiddleware(client *dynamodb.Client) *dynamodb.Client {
	return dynamodb.NewFromConfig(client.Options(), func(o *dynamodb.Options) {
		o.HTTPClient = &loggingHTTPClient{client: o.HTTPClient}
	})
}

// loggingHTTPClient wraps an HTTP client to log requests and responses
type loggingHTTPClient struct {
	client interface{}
}

// Do implements the HTTPClient interface
func (c *loggingHTTPClient) Do(req *http.Request) (*http.Response, error) {
	start := time.Now()
	log.Printf("--> %s %s", req.Method, req.URL.Path)

	// Type assertion to call the underlying client's Do method
	httpClient, ok := c.client.(interface {
		Do(*http.Request) (*http.Response, error)
	})
	if !ok {
		return nil, fmt.Errorf("http client does not implement Do method")
	}

	resp, err := httpClient.Do(req)

	duration := time.Since(start)
	status := 0
	if resp != nil {
		status = resp.StatusCode
	}
	log.Printf("<-- %d %s (%s)", status, http.StatusText(status), duration)

	return resp, err
}

// awsLogger implements the logging.Logger interface for AWS SDK v2
type awsLogger struct {
	logger *log.Logger
}

// Logf logs the formatted message with the given level
func (l *awsLogger) Logf(classification logging.Classification, format string, v ...interface{}) {
	l.logger.Printf("[%s] %s", classification, fmt.Sprintf(format, v...))
}

func main() {
	// Endpoint and region for LocalStack
	endpoint := "http://localhost:4566"
	region := "us-west-2"

	// Load SDK config with custom endpoint and dummy credentials
	cfg, err := config.LoadDefaultConfig(context.TODO(),
		config.WithRegion(region),
		config.WithCredentialsProvider(
			credentials.StaticCredentialsProvider{
				Value: aws.Credentials{
					AccessKeyID:     "test",
					SecretAccessKey: "test",
					SessionToken:    "test",
					Source:          "hardcoded dummy credentials",
				},
			},
		),
	)
	if err != nil {
		log.Fatalf("unable to load SDK config: %v", err)
	}

	// Create a logger that implements the logging.Logger interface
	logger := &awsLogger{logger: log.New(os.Stdout, "[DynamoDB] ", log.LstdFlags)}

	// Create a new DynamoDB client with logging middleware
	client := dynamodb.NewFromConfig(cfg, func(o *dynamodb.Options) {
		o.BaseEndpoint = aws.String(endpoint)
		o.ClientLogMode = aws.LogRequestWithBody | aws.LogResponseWithBody
		o.Logger = logger

		// Add request/response logging middleware
		o.APIOptions = append(o.APIOptions, func(stack *middleware.Stack) error {
			return stack.Initialize.Add(middleware.InitializeMiddlewareFunc("logger",
				func(ctx context.Context, in middleware.InitializeInput, next middleware.InitializeHandler) (
					out middleware.InitializeOutput, metadata middleware.Metadata, err error) {
					logger.Logf(logging.Debug, "Request: %+v", in)
					return next.HandleInitialize(ctx, in)
				},
			), middleware.After)
		})
	})

	// 1. Create table
	tableName := "MyTable"
	_, err = client.CreateTable(context.TODO(), &dynamodb.CreateTableInput{
		TableName: &tableName,
		KeySchema: []types.KeySchemaElement{
			{AttributeName: aws.String("ID"), KeyType: types.KeyTypeHash},
		},
		AttributeDefinitions: []types.AttributeDefinition{
			{AttributeName: aws.String("ID"), AttributeType: types.ScalarAttributeTypeS},
		},
		BillingMode: types.BillingModePayPerRequest,
	})
	if err != nil {
		log.Fatalf("failed to create table: %v", err)
	}
	fmt.Println("Table created:", tableName)

	// 2. Put item into the table
	_, err = client.PutItem(context.TODO(), &dynamodb.PutItemInput{
		TableName: &tableName,
		Item: map[string]types.AttributeValue{
			"ID":   &types.AttributeValueMemberS{Value: "123"},
			"Name": &types.AttributeValueMemberS{Value: "LocalUser"},
		},
	})
	if err != nil {
		log.Fatalf("failed to put item: %v", err)
	}
	fmt.Println("Inserted item into table")

	// 3. Get item
	resp, err := client.GetItem(context.TODO(), &dynamodb.GetItemInput{
		TableName: &tableName,
		Key: map[string]types.AttributeValue{
			"ID": &types.AttributeValueMemberS{Value: "123"},
		},
	})
	if err != nil {
		log.Fatalf("failed to get item: %v", err)
	}

	nameAttr := resp.Item["Name"].(*types.AttributeValueMemberS)
	fmt.Printf("Fetched item: ID=%s, Name=%s\n", "123", nameAttr.Value)
}
